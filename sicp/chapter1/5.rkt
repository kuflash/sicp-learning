#lang racket/base

(require rackunit)

(define (p) (p))

(define (test x y)
  (if 
    (= x 0) 0 
    y
  )
)

;;; (test 0 (p))

;;; При аппликативном методе вычисления сначала вычисляются аргументы
;;; - поэтому результатом будет бесконечная рекурсия,
;;; так как вычислить (p) не возможно - это бесконечно рекурсивная функция

;;; При нормальном методе вычисления сначала вычисляется тело функции
;;; - поэтому будет выполнено тело функции test, и подставлены аргументы
;;; вместо формальных параметров в теле этой функции.
;;; А так как x = 0, то функция вернет 0, и (p) вообще не будет вычислено
